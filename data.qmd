---
title: "Data Work"
author: "K-Means Clustering"
format: 
  html:
    df-print: paged
---

Addison's Code: Libraries:

```{r, error=FALSE, warning=FALSE, message=FALSE}
library(rlang)
library(haven)
library(dplyr)
library(tidyverse)
library(ggplot2)
library(fastDummies)
library(equatiomatic)
library(car)
library(sjPlot)
library(MASS)
library(lmtest)
library(gmodels)
library(tidyr)
library(sjmisc)
library(sjlabelled)
library(naniar)
library(cluster)
library(factoextra)
```

Read data from CSV

```{r}
data <- read_csv("C:/Users/Addison/OneDrive/Documents/SCHOOL/Advanced Statistical Modeling/data.csv")

data <-read_csv("~/STA6257Kmeans/data.csv")
```

We know UK is the primary country associated. Making a data frame excluding UK to better see frequencies of other countries.

```{r}
clean_data_uk <- na.omit(data)

#removing UK
clean_data_trim <- clean_data_uk[clean_data_uk$Country != "United Kingdom",]
```

Summary Stats:

```{r}
summary(clean_data)
summary(clean_data_trim)

#Plot countries
ggplot(clean_data, aes(x=Country)) +
  geom_bar() +
  theme(axis.text.x = element_text(angle=45, vjust=1, hjust=1))

#Create total sales column
clean_data <- clean_data %>% mutate(total = clean_data$Quantity*clean_data$UnitPrice)

#Set category breaks using quantiles
xs=quantile(clean_data$total,c(0,1/3,2/3,1))

#Label category breaks & Plot
df1 <- clean_data %>% mutate(category=cut(total, breaks=xs, labels=c("low","middle","high"),include.lowest = TRUE))
boxplot(df1$total~df1$category)

#Extra cleaning/checking
df1 <- na.omit(df1)
summary(df1)

#Creating some unique subsets for model testing
df2 <- subset(df1, Quantity > 0)
plot <- boxplot(total~category, data = df2)

#
df3 <- df2 %>% dplyr::select(Quantity,UnitPrice,CustomerID,InvoiceDate,total)
customer_data <- df3 %>% group_by(CustomerID) %>% summarize(Sales=sum(total), OrderCount=length(unique(InvoiceDate))) %>% mutate(AvgValue=Sales/OrderCount)
head(customer_data)


#Ranking and Normalization
df3_ranked <- customer_data %>% mutate(Sales=rank(Sales), OrderCount=rank(OrderCount, ties.method = "first"), AvgValue=rank(AvgValue))
df3_norm <- df3_ranked %>% mutate(Sales=scale(Sales), OrderCount=scale(OrderCount), AvgValue=scale(AvgValue))

summary(df3_norm)
sapply(df3_norm, sd)
```

```{r}
set.seed(100)
model1 <- kmeans(df3_norm[c("Sales", "OrderCount", "AvgValue")],4)

model1

df3_norm$Cluster <- model1$cluster
```

```{r}
#Plotting Clustering Results

options(repr.plot.width = 20, repr.plot.height = 15)
ggplot(df3_norm, aes(x=AvgValue, y=OrderCount, color=Cluster)) + 
  geom_point() + 
  theme(legend.position = "right", legend.text=element_text(size=15), axis.title = element_text(size = 10))


fviz_cluster(model1, data = df3_norm,
             palette = c("blue","green","orange","red"),
             geom = "point",
             ellipse.type = "convex",
             ggtheme = theme_bw()
)
```

Aleshas code: -Guys sorry it might be a mess I will be using this space for draft work while figuring this out, and at the end ill cut out what is not needed.

```{r}
library(readr)
library(tidyverse)
library(ggplot2)
#dataEcom <- read_csv("data.csv")
#dataEcom <- dataEcom%>% filter(dataEcom$Country !="United Kingdom") %>% drop_na()

#load data
library(readr)
data <- read_csv("~/STA6257Kmeans/data.csv")
#remove missing values
dataEcom<- na.omit(data)
#select subset of data to avoid bias
dataEcom <- dataEcom%>% filter(dataEcom$Country !="United Kingdom")
#View(data)
head(dataEcom, n=10)
#str(dataEcom)

#install.packages("gtsummary")
#library(gtsummary)
#tbl_summary(dataEcom)

#descriptive statistics, distribution, frequencies
ggplot(dataEcom, aes(x=Country)) +
  geom_bar()+
  theme(axis.text.x =element_text(angle=45,vjust=1,hjust=1))

#Getting the amount of distinct CustomerID values and amount of distinct Descriptions
n_distinct(dataEcom$CustomerID)
n_distinct(dataEcom$Description)
n_distinct(dataEcom$StockCode)
#install.packages("naniar")
library(naniar)
# Plotting percentage of missing values per feature
gg_miss_var(dataEcom, show_pct = TRUE)

# create a df
dfEcom <- as_tibble(dataEcom %>% dplyr::select(StockCode, InvoiceNo, Description,Quantity, InvoiceDate, UnitPrice, CustomerID, Country))
summary(dfEcom)
#look at distribution of data. We will need to consider what variable is of importance or create one. (total amount spent or quantity of items bought)
quantile(dataEcom$Quantity, probs = c(0,0.25,0.5,0.75,1))
#Do we need to worry about removing negative values for quantity? cannot have a negative quantity?
df <- subset(dataEcom, Quantity > 0)
quantile(df2$Quantity, probs = c(0,0.25,0.5,0.75,1))

quantile(df2$UnitPrice, probs = c(0,0.25,0.5,0.75,1))

#how often each customer visits
countCustomerID <- dfEcom %>% mutate %>% count(as.factor(CustomerID))
countCustomerID

#transactions per country
countCountry <- dfEcom %>% mutate %>% count(as.factor(Country))
countCountry

countStockCode <- dfEcom %>% mutate %>% count(as.factor(dfEcom$StockCode))
countStockCode
#visuals of distribution, has issues :(
p1<- ggplot(top_n(dfEcom, 5), aes(x=StockCode)) +
  geom_bar()
p1

p2<- ggplot(top_n(df2,5), aes(x=Quantity)) +
  geom_bar()
p2

#data manipulation, create a new column for total items purchased in a transaction.
#Group by Quantity per InvoiceNo

dfItemTot <- as.data.frame(dfEcom %>% group_by(InvoiceNo) %>%
+   summarise(ItemTot = sum(Quantity)))

dfItemTot <- dfEcom %>% dplyr::select(StockCode,Quantity, InvoiceDate, CustomerID,InvoiceNo,Description,UnitPrice,Country) %>%
  group_by(InvoiceNo) %>%
  summarise(ItemTot = sum(Quantity))%>%drop_na()

df1 <- dfItemTot %>%
  mutate(totalItems = case_when(ItemTot <10 ~ "<10",
                                ItemTot<50 ~ "<50",
                                ItemTot<100~ "<100",
                                ItemTot<400~ "<400",
                                ItemTot<1000~ "<1000",
                                ItemTot>=1000~">=1000"))

longer <- df1 %>%
  pivot_longer(
     cols = c(-InvoiceNo),
     values_to = "ItemTot")

#kmeans
library(cluster)
install.packages("factoextra")
library(factoextra)

df <- na.omit(dataEcom)

km5<-kmeans(dataEcom,5,nstart=25)

k3 <- kmeans(dfEcom, centers = 3, nstart = 25)
str(k3)

k4 <- kmeans(dfEcom, centers = 4, nstart = 25)
str(k4)

k6 <- kmeans(dfEcom, centers = 6, nstart = 25)
str(k6)

#visualization of clusters
fviz_cluster(k3, data = dfEcom)
fviz_cluster(k4, data = dfEcom)
fviz_cluster(k6, data = dfEcom)

```

Columns: InvoiceNo, StockCode, Description, Quantity, InvoiceDate, UnitPrice, CustomerID, Country

There are 422 distinct CustomerID's and 2897 different Item descriptions.

Goals of clustering: unsupervised clustering is more concerned with classification than deep insights. Yet shines a light on features of the data that can be further discovered with deeper analytics. Explorium 2023

The goal of our analysis is to use unsupervised learning reveal patterns and relationships within this ecommerce data. This will create a deeper understanding for the entire customer-ecommerce interaction and improve customer access and experiences. While K-Means clustering creates organization where there are large amounts of unlabeled data, this analysis is just a stepping stone for clarity and deeper investigations.
