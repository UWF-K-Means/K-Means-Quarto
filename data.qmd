---
title: "Data Work"
author: "K-Means Clustering"
format: 
  html:
    df-print: paged
---

Addison's Code: Libraries:

```{r, error=FALSE, warning=FALSE, message=FALSE}
library(rlang)
library(haven)
library(dplyr)
library(tidyverse)
library(ggplot2)
library(fastDummies)
library(equatiomatic)
library(car)
library(sjPlot)
library(MASS)
library(lmtest)
library(gmodels)
library(tidyr)
library(sjmisc)
library(sjlabelled)
library(naniar)
library(cluster)
library(factoextra)
```

Read data from CSV

```{r}
data <- read_csv("C:/Users/sowmy/Desktop/STA_6257/Project_Data/data.csv")

```

We know UK is the primary country associated. Making a data frame excluding UK to better see frequencies of other countries.

```{r}
clean_data_uk <- na.omit(data)

#removing UK
clean_data <- clean_data_uk[clean_data_uk$Country != "United Kingdom",]
```

Summary Stats:

```{r}
summary(clean_data)
summary(clean_data_trim)

#Plot countries
ggplot(clean_data, aes(x=Country)) +
  geom_bar() +
  theme(axis.text.x = element_text(angle=45, vjust=1, hjust=1))

#Create total sales column
clean_data <- clean_data %>% mutate(total = clean_data$Quantity*clean_data$UnitPrice)

#Set category breaks using quantiles
xs=quantile(clean_data$total,c(0,1/3,2/3,1))

#Label category breaks & Plot
df1 <- clean_data %>% mutate(category=cut(total, breaks=xs, labels=c("low","middle","high"),include.lowest = TRUE))
boxplot(df1$total~df1$category)

#Extra cleaning/checking
df1 <- na.omit(df1)
summary(df1)

#Creating some unique subsets for model testing
df2 <- subset(df1, Quantity > 0)
plot <- boxplot(total~category, data = df2)

#
df3 <- df2 %>% dplyr::select(Quantity,UnitPrice,CustomerID,InvoiceDate,total)
customer_data <- df3 %>% group_by(CustomerID) %>% summarize(Sales=sum(total), OrderCount=length(unique(InvoiceDate))) %>% mutate(AvgValue=Sales/OrderCount)
head(customer_data)


#Ranking and Normalization
df3_ranked <- customer_data %>% mutate(Sales=rank(Sales), OrderCount=rank(OrderCount, ties.method = "first"), AvgValue=rank(AvgValue))
df3_norm <- df3_ranked %>% mutate(Sales=scale(Sales), OrderCount=scale(OrderCount), AvgValue=scale(AvgValue))

summary(df3_norm)
sapply(df3_norm, sd)

# Create an empty vector to store WCSS values
wcss <- vector("numeric", length = 10)

# Iterate over a range of K values (e.g., from 1 to 10)
for (i in 1:10) {
  model <- kmeans(df3_norm[c("Sales", "OrderCount", "AvgValue")], centers = i, nstart = 10)
  wcss[i] <- ceiling(model$tot.withinss)
}

# Plot the WCSS values against the number of clusters
library(ggplot2)
ggplot(data.frame(K = 1:10, WCSS = wcss), aes(x = K, y = WCSS)) +
  geom_line() +
  geom_point() +
   labs(title = "Elbow Method to Find Optimal K", x = "Number of Clusters (K)", y = "Within-Cluster-Sum-of-Squares (WCSS)") +
  scale_x_continuous(breaks = seq(0, 10, by = 2))
```

```{r}
set.seed(100)
model1 <- kmeans(df3_norm[c("Sales", "OrderCount", "AvgValue")],4)

model1

df3_norm$Cluster <- model1$cluster
```

```{r}
#Plotting Clustering Results

options(repr.plot.width = 20, repr.plot.height = 15)
ggplot(df3_norm, aes(x=AvgValue, y=OrderCount, color=Cluster)) + 
  geom_point() + 
  theme(legend.position = "right", legend.text=element_text(size=15), axis.title = element_text(size = 10))


fviz_cluster(model1, data = df3_norm,
             palette = c("blue","green","orange","red"),
             geom = "point",
             ellipse.type = "convex",
             ggtheme = theme_bw()
)
```

Aleshas code: -Guys sorry it might be a mess I will be using this space for draft work while figuring this out, and at the end ill cut out what is not needed.

```{r}
library(readr)
library(tidyverse)
library(ggplot2)
library(RColorBrewer)
theme_set(theme_minimal())

data <- read_csv("~/STA6257Kmeans/data.csv")
#remove missing values
clean_data_uk<- na.omit(data)
#removing UK
clean_data <- clean_data_uk[clean_data_uk$Country != "United Kingdom",]

#Top Countries based on InvoiceNo (count of occurrences per country)
topCountries<-clean_data_trim %>%
  count(Country) %>%slice_max(n, n = 5, with_ties = FALSE) %>% 
  ggplot(aes(Country, n)) + 
  geom_col(fill = c("#9900C6", "#E7B800","#3399CC","#00CC66","#FF99FF"))+ 
labs(title = "Top Countries", y="Total Lifetime Transactions")
topCountries

#Lets create a new df with only top 5 customer IDs for Sales, OrderCount, and AvgValue, they may not be all be the same
top5AvgValues <-top_n(customer_data, 5, AvgValue)  
top5Sales <-top_n(customer_data, 5, Sales)
top5OrderCount<-top_n(customer_data,5,OrderCount)
#histogram of average value by CustomerID
p.Avg<-ggplot(top5AvgValues, aes(x=as.factor(CustomerID),y=AvgValue, fill=CustomerID))+ 
  geom_bar(stat="identity")+
  labs(title = "Top 5 Customers by Average Value", x= "CustomerID",y="Total Average Sales")+
  theme(plot.title = element_text(color = "#0099f9", size = 20))
  #scale_color_brewer(palette="dark2")
p.Avg
#histogram of top sales by CustomerID
p.Sales<-ggplot(top5Sales, aes(x=as.factor(CustomerID),y=Sales, fill=CustomerID))+ 
  geom_bar(stat="identity")+
  labs(title = "Top 5 Customers by Lifetime Sales", x= "CustomerID",y="Lifetime Customer Sales")+
  theme(plot.title = element_text(color = "#0099f9", size = 20))
  #scale_color_brewer(palette="dark2")
p.Sales
#histogram of top OrderCount by CustomerID
p.Orders<-ggplot(top5OrderCount, aes(x=as.factor(CustomerID),y=OrderCount, fill=CustomerID))+ 
  geom_bar(stat="identity")+
  labs(title = "Top 5 Customers by OrderCount", x= "CustomerID",y="Lifetime Order Totals")+
  theme(plot.title = element_text(color = "#0099f9", size = 20))
  #scale_color_brewer(palette="dark2")
p.Orders
par(mfrow=c(3,3))


```

```{r}
# Temporary notes and additional code for Alesha, will remove Sunday.
#set up data frame in descending order by total sales per Customer ID selecting top 5 values
data_new2<- df3%>%arrange(desc(total))%>%group_by(CustomerID)%>%slice(1:5)
data_new3<- customer_data%>%arrange(desc(AvgValue))%>%group_by(CustomerID)%>%slice(1:5)

#histogram of top 5 transactions based on total spent in a transaction.
topSales<- ggplot(data_new2, aes(CustomerID), group=CustomerID) + 
  geom_histogram(bins=5, fill =c("#9900C6","#E7B800","#3399CC","#00CC66","#FF99FF"))+
labs(title = "Top 5 Customers by Sales", x= "CustomerID",y="Lifetime Sales Total")+
 theme(plot.title = element_text(color = "#0099f9", size = 20))
topSales

#histogram of top 5 AvgValue by CustomerID
topSales<-ggplot(data=data_new3,aes(x=CustomerID,y=AvgValue,fill=CustomerID))+
 geom_bar() +
 scale_fill_manual(values = c("#9900C6", "#E7B800","#3399CC","#00CC66","#FF99FF"))
topSales

#AvgSales
avgSalePlot<- ggplot(customer_data, aes(CustomerID))+
geom_histogram( fill =c("#9900C6","#E7B800","#3399CC","#00CC66","#FF99FF"))+
theme(plot.title = element_text(color = "#0099f9", size = 20))
topSales
#Plot to show who's CustomerID's account for the top 5 greatest Quantity of items in a transaction. Not correct, data_new2 should be selecting top 5 in descending order
quantPlot<-ggplot(data=data_new2, aes(x=CustomerID, y=Quantity, fill=(CustomerID), group=CustomerID))+
  geom_bar(stat='identity')
quantPlot
#histogram of orderCount top 5
topOrderCount<-customer_data %>% slice_max(CustomerID, n = 5, with_ties = FALSE) %>%
  ggplot(aes(OrderCount, n)) + 
  scale_fill_manual(values = c("#9900C6", "#E7B800","#3399CC","#00CC66","#FF99FF"))
topOrderCount

#histogram of Sales
topSales<-
  ggplot(top5AvgSales, 
  aes(x=Sales, group=CustomerID, fill=CustomerID))+
  geom_histogram()+
  labs(title = "Top 5 Sales", x= "Sales",y="Count")
top5AvgSales

top5Sales<-
  ggplot(data_new3, 
  aes(x=CustomerID, group=CustomerID, fill=CustomerID))+
  geom_histogram(bins=5)+
  labs(title = "Top 5 CustomersID's by Average Sales", x= "CustomerID",y="Average Sales")
top5AvgSales

ggplot(df, aes(x = values, y = freq)) +
       geom_bar(stat="identity")
```

Columns: InvoiceNo, StockCode, Description, Quantity, InvoiceDate, UnitPrice, CustomerID, Country, total

Goals of clustering: unsupervised clustering is more concerned with classification than deep insights. Yet shines a light on features of the data that can be further discovered with deeper analytics. Explorium 2023

The goal of our analysis is to use unsupervised learning reveal patterns and relationships within this ecommerce data. This will create a deeper understanding for the entire customer-ecommerce interaction and improve customer access and experiences. While K-Means clustering creates organization where there are large amounts of unlabeled data, this analysis is just a stepping stone for clarity and deeper investigations.
